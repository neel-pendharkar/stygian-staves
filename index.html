<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Mini Music App - Random Chords + Metronome</title>
  <script src="https://cdn.jsdelivr.net/npm/vexflow/releases/vexflow-min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      font-size: 20px;
    }

    #targetWrapper {
      width: 100%;
      border: 2px solid #ccc;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 20px;
    }

    .chordName {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
    }

    #targetSheet {
      font-size: 32px;
      text-align: center;
    }

    #devices, #bpmControl {
      margin-top: 20px;
    }
  </style>
</head>
<body>

<h1>Mini Music App – Random Chords</h1>
<div id="status">Waiting for MIDI…</div>
<div id="devices"></div>

<div id="targetWrapper">
  <div id="chordName" class="chordName">Chord Name</div>
  <div id="targetSheet"></div>
</div>

<div id="bpmControl">
  <label>BPM: <input type="number" id="bpmInput" value="60" min="30" max="240"></label>
</div>

<script>
/* -------------------- Constants -------------------- */
const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const C4 = 60, C5 = 72;

/* -------------------- State -------------------- */
let targetChord = [];
let playedNotes = new Set();

/* -------------------- MIDI Utils -------------------- */
function midiToName(n){
  return NOTE_NAMES[n % 12] + (Math.floor(n / 12) - 1);
}

/* -------------------- Chord Logic -------------------- */
function getRandomChord(){
  const root = Math.floor(Math.random() * (C5 - C4)) + C4;
  const isMinor = Math.random() < 0.5;
  return isMinor ? [root, root+3, root+7] : [root, root+4, root+7];
}

// Determine chord name (basic triads only)
function getChordName(chord){
  if(chord.length !== 3) return "Unknown";
  const rootName = NOTE_NAMES[chord[0]%12];
  const interval1 = chord[1] - chord[0];
  const interval2 = chord[2] - chord[1];
  if(interval1 === 4 && interval2 === 3) return rootName + " Major";
  if(interval1 === 3 && interval2 === 4) return rootName + " Minor";
  return "Unknown";
}

/* -------------------- Sheet Music -------------------- */
function drawChord(midiNotes, highlightNotes=[]){
  const container = document.getElementById("targetSheet");
  container.innerHTML = "";
  const VF = Vex.Flow;
  const renderer = new VF.Renderer(container, VF.Renderer.Backends.SVG);
  renderer.resize(300,180);
  const ctx = renderer.getContext();

  const stave = new VF.Stave(10,40,280);
  stave.addClef("treble").setContext(ctx).draw();

  const keys = midiNotes.map(n=>{
    const name = NOTE_NAMES[n%12].toLowerCase();
    const octave = Math.floor(n/12)-1;
    return `${name}/${octave}`;
  });

  const note = new VF.StaveNote({clef:"treble", keys, duration:"q"});
  keys.forEach((k,i)=>{
    if(k.includes("#")) note.addAccidental(i,new VF.Accidental("#"));
    if(highlightNotes.includes(midiNotes[i])){
      note.setKeyStyle(i,{fillStyle:"green", strokeStyle:"green"});
    }
  });

  const voice = new VF.Voice({num_beats:1, beat_value:4});
  voice.addTickables([note]);
  new VF.Formatter().joinVoices([voice]).format([voice],250);
  voice.draw(ctx, stave);
}

/* -------------------- Game Logic -------------------- */
function newChord(){
  playedNotes.clear();
  targetChord = getRandomChord();
  document.getElementById("chordName").textContent = getChordName(targetChord);
  drawChord(targetChord, []);
}

function checkChord(){
  const allCorrect = targetChord.every(n => playedNotes.has(n));
  if(allCorrect) newChord();
}

/* -------------------- MIDI Handling -------------------- */
function handleMidiMessage(msg){
  const [type, note, velocity] = msg.data;

  if(type === 144 && velocity>0) playedNotes.add(note); // note-on
  else if(type===128 || (type===144 && velocity===0)) playedNotes.delete(note); // note-off

  drawChord(targetChord, [...playedNotes]);
  checkChord();
}

/* -------------------- MIDI Init -------------------- */
function initMidi(){
  navigator.requestMIDIAccess().then(midi=>{
    document.getElementById("status").textContent="MIDI ready";
    for(const input of midi.inputs.values()){
      input.onmidimessage=handleMidiMessage;
    }
    newChord();
  });
}

/* -------------------- Metronome -------------------- */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let bpm = parseInt(document.getElementById("bpmInput").value);
let metronomeInterval = null;

function playClick(){
  const bufferSize = audioCtx.sampleRate*0.02;
  const buffer = audioCtx.createBuffer(1,bufferSize,audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i]=Math.random()*2-1;
  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  const gainNode = audioCtx.createGain();
  gainNode.gain.setValueAtTime(0.3,audioCtx.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+0.02);
  noise.connect(gainNode); gainNode.connect(audioCtx.destination);
  noise.start(); noise.stop(audioCtx.currentTime+0.02);
}

function startMetronome(){
  if(metronomeInterval) clearInterval(metronomeInterval);
  metronomeInterval = setInterval(playClick, (60/bpm)*1000);
}

document.getElementById("bpmInput").addEventListener("change", e=>{
  bpm=parseInt(e.target.value);
  startMetronome();
});

// Resume audio on first interaction
function resumeAudio(){
  if(audioCtx.state==="suspended") audioCtx.resume();
}
document.body.addEventListener("click", resumeAudio,{once:true});
document.body.addEventListener("touchstart", resumeAudio,{once:true});

/* -------------------- Start App -------------------- */
initMidi();
startMetronome();
</script>

</body>
</html>
